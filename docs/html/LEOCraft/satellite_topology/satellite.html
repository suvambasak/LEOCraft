<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>LEOCraft.satellite_topology.satellite API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>LEOCraft.satellite_topology.satellite</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math

import ephem
from astropy import units as u
from astropy.time import Time, TimeDelta


class LEOSatellite:
    &#34;&#34;&#34;
    A LEO satellite class 

    - Generates TLE of a satellite
    - Computes
        - Satellite nadir at given time (satellite propagation)
        - orbital period
        - Coverage cone on Earth surface
        - Maximum range of ground to satellite, inter satellite links


    Reference:
    [1] https://github.com/snkas/hypatia/tree/master/satgenpy
    [2] Kassing S, Bhattacherjee D, Águas AB, Saethre JE, Singla A. Exploring the&#34; Internet from space&#34; with Hypatia. InProceedings of the ACM Internet Measurement conference 2020 Oct 27 (pp. 214-229).
    &#34;&#34;&#34;

    # Constant for Earth
    EARTH_RADIUS_M: float = 6378135.0
    G: float = 6.67408 * 10**(-11)
    MASS: float = 5.9722*(10**24)

    # Circular orbit
    ECCENTRICITY: float = 0.0000001
    ARG_OF_PERIGEE_DEGREE: float = 0.0

    def __init__(
        self,
        altitude_m: float,
        inclination_degree: float,
        angle_of_elevation_degree: float,

        satellite_catalog_number: int,
        raan_degree: float,
        mean_anomaly_degree: float,
        satellite_name: str = &#39;LEOSAT&#39;
    ) -&gt; None:
        &#34;&#34;&#34;Create a new satellites object

        Parameters
        ----------
        altitude_m : float
            Satellite altitude in meter(s)
        inclination_degree : float
            Angle of inclination in degree
        angle_of_elevation_degree: float
            Min angle of elevation in degree
        satellite_catalog_number: int
            Unique ID for satellite
        raan_degree: float
            Right Ascension of the Ascending Node (RAAN) in degree
        mean_anomaly_degree: float
            Mean anomaly in degree
        satellite_name: str
            Name of the container shell
        &#34;&#34;&#34;

        assert satellite_catalog_number &gt; 0
        assert len(satellite_name) &gt; 0

        if altitude_m &lt; 300000.0 or altitude_m &gt; 2000000.0:
            raise ValueError(
                &#34;[Required] 300.0 KM &lt;= altitude_m &lt;= 2000.0 KM&#34;
            )
        if inclination_degree &lt; 0.0 or inclination_degree &gt; 180.0:
            raise ValueError(
                &#34;[Required] 5.0 &lt;= inclination_degree &lt;= 175.0&#34;
            )
        if angle_of_elevation_degree &lt; 1.0 or angle_of_elevation_degree &gt; 90.0:
            raise ValueError(
                &#34;[Required] 5.0 &lt;= angle_of_elevation_degree &lt;= 90.0&#34;
            )
        if raan_degree &lt; 0.0 or raan_degree &gt; 360.0:
            raise ValueError(
                &#34;[Required] 0.0 &lt;= raan_degree &lt;= 360.0&#34;
            )
        if mean_anomaly_degree &lt; 0.0 or mean_anomaly_degree &gt; 360.0:
            raise ValueError(
                &#34;[Required] 0.0 &lt;= mean_anomaly_degree &lt;= 360.0&#34;
            )

        self.altitude_m = float(altitude_m)
        self.inclination_degree = float(inclination_degree)
        self.angle_of_elevation_e_degree = float(angle_of_elevation_degree)

        self.satellite_catalog_number = satellite_catalog_number
        self.raan_degree = raan_degree
        self.mean_anomaly_degree = mean_anomaly_degree
        self.satellite_name = satellite_name

        self.MEAN_MOTION_REV_PER_DAY = (24*60*60)/self.orbital_period_s()

        # TLE
        self.tle_line_1: str
        self.tle_line_2: str
        self.title_line: str

    def get_satellite(self) -&gt; ephem.EarthSatellite:
        &#34;&#34;&#34;Get ephem instance

        Returns
        -------
        ephem.EarthSatellite
            ephem build with TLE
        &#34;&#34;&#34;
        return ephem.readtle(self.title_line, self.tle_line_1, self.tle_line_2)

    def build(self) -&gt; None:
        &#34;Create TLE of the satellite and epoch&#34;

        self._build_TLE()
        epoch_year = self.tle_line_1[18:20]
        epoch_day = float(self.tle_line_1[20:32])
        self.epoch = Time(&#34;20&#34; + epoch_year + &#34;-01-01 00:00:00&#34;,
                          scale=&#34;tdb&#34;) + (epoch_day - 1) * u.day

    def nadir(
        self, time_delta: TimeDelta = TimeDelta(0.0 * u.nanosecond)
    ) -&gt; tuple[float, float, float]:
        &#34;&#34;&#34;Calculates satellite shadow/nadir (latitude, longitude, elevation in meter) at given time by default at epoch 

        Parameters
        ----------
        time_delta : float, optional
            Time passed from the epoch

        Returns
        -------
        tuple[float, float, float]
            (latitude, longitude, elevation in meter)
        &#34;&#34;&#34;

        _satellite = self.get_satellite()
        _satellite.compute(
            str(self.epoch+time_delta),
            epoch=str(self.epoch)
        )
        return math.degrees(_satellite.sublat), math.degrees(_satellite.sublong),  _satellite.elevation

    def _build_TLE(self) -&gt; None:
        &#39;Create TLE three line&#39;

        # Epoch is 2000-01-01 00:00:00, which is 00001 in ddyyy format
        # See also: https://www.celestrak.com/columns/v04n03/#FAQ04
        self.tle_line_1 = &#34;1 %05dU 00000ABC 00001.00000000  .00000000  00000-0  00000+0 0    0&#34; % (
            self.satellite_catalog_number
        )

        self.tle_line_2 = &#34;2 %05d %s %s %s %s %s %s    0&#34; % (
            self.satellite_catalog_number,
            (&#34;%3.4f&#34; % self.inclination_degree).rjust(8),
            (&#34;%3.4f&#34; % self.raan_degree).rjust(8),
            (&#34;%0.7f&#34; % self.ECCENTRICITY)[2:],
            (&#34;%3.4f&#34; % self.ARG_OF_PERIGEE_DEGREE).rjust(8),
            (&#34;%3.4f&#34; % self.mean_anomaly_degree).rjust(8),
            (&#34;%2.8f&#34; % self.MEAN_MOTION_REV_PER_DAY).rjust(11),
        )

        # Append checksums
        self.tle_line_1 = self.tle_line_1 + \
            str(self._calculate_tle_line_checksum(self.tle_line_1))
        self.tle_line_2 = self.tle_line_2 + \
            str(self._calculate_tle_line_checksum(self.tle_line_2))
        self.title_line = self.satellite_name + &#34; &#34; + \
            str(self.satellite_catalog_number-1)

    def _calculate_tle_line_checksum(self, tle_line_without_checksum: str) -&gt; int:
        if len(tle_line_without_checksum) != 68:
            raise ValueError(&#34;Must have exactly 68 characters&#34;)
        s = 0
        for i in range(len(tle_line_without_checksum)):
            if tle_line_without_checksum[i].isnumeric():
                s += int(tle_line_without_checksum[i])
            if tle_line_without_checksum[i] == &#34;-&#34;:
                s += 1
        return s % 10

    def get_TLE(self) -&gt; str:
        &#34;&#34;&#34;Get the TLE of the satellite

        Returns
        -------
        str
            SAT_NAME CATALOG_NUM
            1 00002U 00000ABC 00001.00000000  .00000000  00000-0  00000+0 0    05
            2 00002  90.0000   0.0000 0000001   0.0000  36.0000 15.21916082    08
        &#34;&#34;&#34;
        return f&#39;{self.title_line}\n{self.tle_line_1}\n{self.tle_line_2}&#39;

    def coverage_cone_radius_m(self, ut_altitude_m: float = 0.0) -&gt; float:
        &#34;&#34;&#34;Calculates satellite coverage cone radius on a given altitude (default 0m) from earth

        Parameters
        -------
        ut_altitude_m: float, optional
            User Terminal altitude in meters


        Returns
        -------
        float
            radius in meter(s)
        &#34;&#34;&#34;

        return (self.altitude_m-ut_altitude_m) / math.tan(math.radians(self.angle_of_elevation_e_degree))

    def orbital_period_s(self) -&gt; float:
        &#34;&#34;&#34;Calculates orbital period of the satellite in seconds
        Returns
        -------
        float
            second(s)
        &#34;&#34;&#34;

        orbit_radius = self.EARTH_RADIUS_M + self.altitude_m
        return math.sqrt(
            (4 * (math.pi**2) * orbit_radius**3)/(self.G * self.MASS)
        )

    def max_GSL_length_m(self, ut_altitude_m: float = 0.0) -&gt; float:
        &#34;&#34;&#34;Calculates maximum possible GSL length in meters at a given altitude (default 0m)

        Parameters
        -------
        ut_altitude_m: float, optional
            User Terminal altitude in meters

        Returns
        -------
        float
            length in meter(s)
        &#34;&#34;&#34;

        _coverage_cone_radius_m = self.coverage_cone_radius_m(ut_altitude_m)
        return math.sqrt(
            math.pow(_coverage_cone_radius_m, 2) +
            math.pow((self.altitude_m-ut_altitude_m), 2)
        )

    def max_ISL_length_m(self) -&gt; float:
        &#34;&#34;&#34;Calculates maximum possible ISL length(m) which is upto 80km above Earth surface

        Returns
        -------
        float
            length in meter(s)
        &#34;&#34;&#34;
        return 2 * math.sqrt(
            math.pow(self.EARTH_RADIUS_M + self.altitude_m, 2) -
            math.pow(self.EARTH_RADIUS_M + 80000, 2)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite"><code class="flex name class">
<span>class <span class="ident">LEOSatellite</span></span>
<span>(</span><span>altitude_m: float, inclination_degree: float, angle_of_elevation_degree: float, satellite_catalog_number: int, raan_degree: float, mean_anomaly_degree: float, satellite_name: str = 'LEOSAT')</span>
</code></dt>
<dd>
<div class="desc"><p>A LEO satellite class </p>
<ul>
<li>Generates TLE of a satellite</li>
<li>Computes<ul>
<li>Satellite nadir at given time (satellite propagation)</li>
<li>orbital period</li>
<li>Coverage cone on Earth surface</li>
<li>Maximum range of ground to satellite, inter satellite links</li>
</ul>
</li>
</ul>
<p>Reference:
[1] <a href="https://github.com/snkas/hypatia/tree/master/satgenpy">https://github.com/snkas/hypatia/tree/master/satgenpy</a>
[2] Kassing S, Bhattacherjee D, Águas AB, Saethre JE, Singla A. Exploring the" Internet from space" with Hypatia. InProceedings of the ACM Internet Measurement conference 2020 Oct 27 (pp. 214-229).</p>
<p>Create a new satellites object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>altitude_m</code></strong> :&ensp;<code>float</code></dt>
<dd>Satellite altitude in meter(s)</dd>
<dt><strong><code>inclination_degree</code></strong> :&ensp;<code>float</code></dt>
<dd>Angle of inclination in degree</dd>
<dt><strong><code>angle_of_elevation_degree</code></strong> :&ensp;<code>float</code></dt>
<dd>Min angle of elevation in degree</dd>
<dt><strong><code>satellite_catalog_number</code></strong> :&ensp;<code>int</code></dt>
<dd>Unique ID for satellite</dd>
<dt><strong><code>raan_degree</code></strong> :&ensp;<code>float</code></dt>
<dd>Right Ascension of the Ascending Node (RAAN) in degree</dd>
<dt><strong><code>mean_anomaly_degree</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean anomaly in degree</dd>
<dt><strong><code>satellite_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the container shell</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LEOSatellite:
    &#34;&#34;&#34;
    A LEO satellite class 

    - Generates TLE of a satellite
    - Computes
        - Satellite nadir at given time (satellite propagation)
        - orbital period
        - Coverage cone on Earth surface
        - Maximum range of ground to satellite, inter satellite links


    Reference:
    [1] https://github.com/snkas/hypatia/tree/master/satgenpy
    [2] Kassing S, Bhattacherjee D, Águas AB, Saethre JE, Singla A. Exploring the&#34; Internet from space&#34; with Hypatia. InProceedings of the ACM Internet Measurement conference 2020 Oct 27 (pp. 214-229).
    &#34;&#34;&#34;

    # Constant for Earth
    EARTH_RADIUS_M: float = 6378135.0
    G: float = 6.67408 * 10**(-11)
    MASS: float = 5.9722*(10**24)

    # Circular orbit
    ECCENTRICITY: float = 0.0000001
    ARG_OF_PERIGEE_DEGREE: float = 0.0

    def __init__(
        self,
        altitude_m: float,
        inclination_degree: float,
        angle_of_elevation_degree: float,

        satellite_catalog_number: int,
        raan_degree: float,
        mean_anomaly_degree: float,
        satellite_name: str = &#39;LEOSAT&#39;
    ) -&gt; None:
        &#34;&#34;&#34;Create a new satellites object

        Parameters
        ----------
        altitude_m : float
            Satellite altitude in meter(s)
        inclination_degree : float
            Angle of inclination in degree
        angle_of_elevation_degree: float
            Min angle of elevation in degree
        satellite_catalog_number: int
            Unique ID for satellite
        raan_degree: float
            Right Ascension of the Ascending Node (RAAN) in degree
        mean_anomaly_degree: float
            Mean anomaly in degree
        satellite_name: str
            Name of the container shell
        &#34;&#34;&#34;

        assert satellite_catalog_number &gt; 0
        assert len(satellite_name) &gt; 0

        if altitude_m &lt; 300000.0 or altitude_m &gt; 2000000.0:
            raise ValueError(
                &#34;[Required] 300.0 KM &lt;= altitude_m &lt;= 2000.0 KM&#34;
            )
        if inclination_degree &lt; 0.0 or inclination_degree &gt; 180.0:
            raise ValueError(
                &#34;[Required] 5.0 &lt;= inclination_degree &lt;= 175.0&#34;
            )
        if angle_of_elevation_degree &lt; 1.0 or angle_of_elevation_degree &gt; 90.0:
            raise ValueError(
                &#34;[Required] 5.0 &lt;= angle_of_elevation_degree &lt;= 90.0&#34;
            )
        if raan_degree &lt; 0.0 or raan_degree &gt; 360.0:
            raise ValueError(
                &#34;[Required] 0.0 &lt;= raan_degree &lt;= 360.0&#34;
            )
        if mean_anomaly_degree &lt; 0.0 or mean_anomaly_degree &gt; 360.0:
            raise ValueError(
                &#34;[Required] 0.0 &lt;= mean_anomaly_degree &lt;= 360.0&#34;
            )

        self.altitude_m = float(altitude_m)
        self.inclination_degree = float(inclination_degree)
        self.angle_of_elevation_e_degree = float(angle_of_elevation_degree)

        self.satellite_catalog_number = satellite_catalog_number
        self.raan_degree = raan_degree
        self.mean_anomaly_degree = mean_anomaly_degree
        self.satellite_name = satellite_name

        self.MEAN_MOTION_REV_PER_DAY = (24*60*60)/self.orbital_period_s()

        # TLE
        self.tle_line_1: str
        self.tle_line_2: str
        self.title_line: str

    def get_satellite(self) -&gt; ephem.EarthSatellite:
        &#34;&#34;&#34;Get ephem instance

        Returns
        -------
        ephem.EarthSatellite
            ephem build with TLE
        &#34;&#34;&#34;
        return ephem.readtle(self.title_line, self.tle_line_1, self.tle_line_2)

    def build(self) -&gt; None:
        &#34;Create TLE of the satellite and epoch&#34;

        self._build_TLE()
        epoch_year = self.tle_line_1[18:20]
        epoch_day = float(self.tle_line_1[20:32])
        self.epoch = Time(&#34;20&#34; + epoch_year + &#34;-01-01 00:00:00&#34;,
                          scale=&#34;tdb&#34;) + (epoch_day - 1) * u.day

    def nadir(
        self, time_delta: TimeDelta = TimeDelta(0.0 * u.nanosecond)
    ) -&gt; tuple[float, float, float]:
        &#34;&#34;&#34;Calculates satellite shadow/nadir (latitude, longitude, elevation in meter) at given time by default at epoch 

        Parameters
        ----------
        time_delta : float, optional
            Time passed from the epoch

        Returns
        -------
        tuple[float, float, float]
            (latitude, longitude, elevation in meter)
        &#34;&#34;&#34;

        _satellite = self.get_satellite()
        _satellite.compute(
            str(self.epoch+time_delta),
            epoch=str(self.epoch)
        )
        return math.degrees(_satellite.sublat), math.degrees(_satellite.sublong),  _satellite.elevation

    def _build_TLE(self) -&gt; None:
        &#39;Create TLE three line&#39;

        # Epoch is 2000-01-01 00:00:00, which is 00001 in ddyyy format
        # See also: https://www.celestrak.com/columns/v04n03/#FAQ04
        self.tle_line_1 = &#34;1 %05dU 00000ABC 00001.00000000  .00000000  00000-0  00000+0 0    0&#34; % (
            self.satellite_catalog_number
        )

        self.tle_line_2 = &#34;2 %05d %s %s %s %s %s %s    0&#34; % (
            self.satellite_catalog_number,
            (&#34;%3.4f&#34; % self.inclination_degree).rjust(8),
            (&#34;%3.4f&#34; % self.raan_degree).rjust(8),
            (&#34;%0.7f&#34; % self.ECCENTRICITY)[2:],
            (&#34;%3.4f&#34; % self.ARG_OF_PERIGEE_DEGREE).rjust(8),
            (&#34;%3.4f&#34; % self.mean_anomaly_degree).rjust(8),
            (&#34;%2.8f&#34; % self.MEAN_MOTION_REV_PER_DAY).rjust(11),
        )

        # Append checksums
        self.tle_line_1 = self.tle_line_1 + \
            str(self._calculate_tle_line_checksum(self.tle_line_1))
        self.tle_line_2 = self.tle_line_2 + \
            str(self._calculate_tle_line_checksum(self.tle_line_2))
        self.title_line = self.satellite_name + &#34; &#34; + \
            str(self.satellite_catalog_number-1)

    def _calculate_tle_line_checksum(self, tle_line_without_checksum: str) -&gt; int:
        if len(tle_line_without_checksum) != 68:
            raise ValueError(&#34;Must have exactly 68 characters&#34;)
        s = 0
        for i in range(len(tle_line_without_checksum)):
            if tle_line_without_checksum[i].isnumeric():
                s += int(tle_line_without_checksum[i])
            if tle_line_without_checksum[i] == &#34;-&#34;:
                s += 1
        return s % 10

    def get_TLE(self) -&gt; str:
        &#34;&#34;&#34;Get the TLE of the satellite

        Returns
        -------
        str
            SAT_NAME CATALOG_NUM
            1 00002U 00000ABC 00001.00000000  .00000000  00000-0  00000+0 0    05
            2 00002  90.0000   0.0000 0000001   0.0000  36.0000 15.21916082    08
        &#34;&#34;&#34;
        return f&#39;{self.title_line}\n{self.tle_line_1}\n{self.tle_line_2}&#39;

    def coverage_cone_radius_m(self, ut_altitude_m: float = 0.0) -&gt; float:
        &#34;&#34;&#34;Calculates satellite coverage cone radius on a given altitude (default 0m) from earth

        Parameters
        -------
        ut_altitude_m: float, optional
            User Terminal altitude in meters


        Returns
        -------
        float
            radius in meter(s)
        &#34;&#34;&#34;

        return (self.altitude_m-ut_altitude_m) / math.tan(math.radians(self.angle_of_elevation_e_degree))

    def orbital_period_s(self) -&gt; float:
        &#34;&#34;&#34;Calculates orbital period of the satellite in seconds
        Returns
        -------
        float
            second(s)
        &#34;&#34;&#34;

        orbit_radius = self.EARTH_RADIUS_M + self.altitude_m
        return math.sqrt(
            (4 * (math.pi**2) * orbit_radius**3)/(self.G * self.MASS)
        )

    def max_GSL_length_m(self, ut_altitude_m: float = 0.0) -&gt; float:
        &#34;&#34;&#34;Calculates maximum possible GSL length in meters at a given altitude (default 0m)

        Parameters
        -------
        ut_altitude_m: float, optional
            User Terminal altitude in meters

        Returns
        -------
        float
            length in meter(s)
        &#34;&#34;&#34;

        _coverage_cone_radius_m = self.coverage_cone_radius_m(ut_altitude_m)
        return math.sqrt(
            math.pow(_coverage_cone_radius_m, 2) +
            math.pow((self.altitude_m-ut_altitude_m), 2)
        )

    def max_ISL_length_m(self) -&gt; float:
        &#34;&#34;&#34;Calculates maximum possible ISL length(m) which is upto 80km above Earth surface

        Returns
        -------
        float
            length in meter(s)
        &#34;&#34;&#34;
        return 2 * math.sqrt(
            math.pow(self.EARTH_RADIUS_M + self.altitude_m, 2) -
            math.pow(self.EARTH_RADIUS_M + 80000, 2)
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.ARG_OF_PERIGEE_DEGREE"><code class="name">var <span class="ident">ARG_OF_PERIGEE_DEGREE</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.EARTH_RADIUS_M"><code class="name">var <span class="ident">EARTH_RADIUS_M</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.ECCENTRICITY"><code class="name">var <span class="ident">ECCENTRICITY</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.G"><code class="name">var <span class="ident">G</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.MASS"><code class="name">var <span class="ident">MASS</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Create TLE of the satellite and epoch</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self) -&gt; None:
    &#34;Create TLE of the satellite and epoch&#34;

    self._build_TLE()
    epoch_year = self.tle_line_1[18:20]
    epoch_day = float(self.tle_line_1[20:32])
    self.epoch = Time(&#34;20&#34; + epoch_year + &#34;-01-01 00:00:00&#34;,
                      scale=&#34;tdb&#34;) + (epoch_day - 1) * u.day</code></pre>
</details>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.coverage_cone_radius_m"><code class="name flex">
<span>def <span class="ident">coverage_cone_radius_m</span></span>(<span>self, ut_altitude_m: float = 0.0) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates satellite coverage cone radius on a given altitude (default 0m) from earth</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ut_altitude_m</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>User Terminal altitude in meters</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>radius in meter(s)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coverage_cone_radius_m(self, ut_altitude_m: float = 0.0) -&gt; float:
    &#34;&#34;&#34;Calculates satellite coverage cone radius on a given altitude (default 0m) from earth

    Parameters
    -------
    ut_altitude_m: float, optional
        User Terminal altitude in meters


    Returns
    -------
    float
        radius in meter(s)
    &#34;&#34;&#34;

    return (self.altitude_m-ut_altitude_m) / math.tan(math.radians(self.angle_of_elevation_e_degree))</code></pre>
</details>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.get_TLE"><code class="name flex">
<span>def <span class="ident">get_TLE</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the TLE of the satellite</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>SAT_NAME CATALOG_NUM
1 00002U 00000ABC 00001.00000000
.00000000
00000-0
00000+0 0
05
2 00002
90.0000
0.0000 0000001
0.0000
36.0000 15.21916082
08</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_TLE(self) -&gt; str:
    &#34;&#34;&#34;Get the TLE of the satellite

    Returns
    -------
    str
        SAT_NAME CATALOG_NUM
        1 00002U 00000ABC 00001.00000000  .00000000  00000-0  00000+0 0    05
        2 00002  90.0000   0.0000 0000001   0.0000  36.0000 15.21916082    08
    &#34;&#34;&#34;
    return f&#39;{self.title_line}\n{self.tle_line_1}\n{self.tle_line_2}&#39;</code></pre>
</details>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.get_satellite"><code class="name flex">
<span>def <span class="ident">get_satellite</span></span>(<span>self) ‑> ephem.EarthSatellite</span>
</code></dt>
<dd>
<div class="desc"><p>Get ephem instance</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ephem.EarthSatellite</code></dt>
<dd>ephem build with TLE</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_satellite(self) -&gt; ephem.EarthSatellite:
    &#34;&#34;&#34;Get ephem instance

    Returns
    -------
    ephem.EarthSatellite
        ephem build with TLE
    &#34;&#34;&#34;
    return ephem.readtle(self.title_line, self.tle_line_1, self.tle_line_2)</code></pre>
</details>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.max_GSL_length_m"><code class="name flex">
<span>def <span class="ident">max_GSL_length_m</span></span>(<span>self, ut_altitude_m: float = 0.0) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates maximum possible GSL length in meters at a given altitude (default 0m)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ut_altitude_m</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>User Terminal altitude in meters</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>length in meter(s)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_GSL_length_m(self, ut_altitude_m: float = 0.0) -&gt; float:
    &#34;&#34;&#34;Calculates maximum possible GSL length in meters at a given altitude (default 0m)

    Parameters
    -------
    ut_altitude_m: float, optional
        User Terminal altitude in meters

    Returns
    -------
    float
        length in meter(s)
    &#34;&#34;&#34;

    _coverage_cone_radius_m = self.coverage_cone_radius_m(ut_altitude_m)
    return math.sqrt(
        math.pow(_coverage_cone_radius_m, 2) +
        math.pow((self.altitude_m-ut_altitude_m), 2)
    )</code></pre>
</details>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.max_ISL_length_m"><code class="name flex">
<span>def <span class="ident">max_ISL_length_m</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates maximum possible ISL length(m) which is upto 80km above Earth surface</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>length in meter(s)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_ISL_length_m(self) -&gt; float:
    &#34;&#34;&#34;Calculates maximum possible ISL length(m) which is upto 80km above Earth surface

    Returns
    -------
    float
        length in meter(s)
    &#34;&#34;&#34;
    return 2 * math.sqrt(
        math.pow(self.EARTH_RADIUS_M + self.altitude_m, 2) -
        math.pow(self.EARTH_RADIUS_M + 80000, 2)
    )</code></pre>
</details>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.nadir"><code class="name flex">
<span>def <span class="ident">nadir</span></span>(<span>self, time_delta: astropy.time.core.TimeDelta = &lt;TimeDelta object: scale=&#x27;None&#x27; format=&#x27;jd&#x27; value=0.0&gt;) ‑> tuple[float, float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates satellite shadow/nadir (latitude, longitude, elevation in meter) at given time by default at epoch </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time_delta</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Time passed from the epoch</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[float, float, float]</code></dt>
<dd>(latitude, longitude, elevation in meter)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nadir(
    self, time_delta: TimeDelta = TimeDelta(0.0 * u.nanosecond)
) -&gt; tuple[float, float, float]:
    &#34;&#34;&#34;Calculates satellite shadow/nadir (latitude, longitude, elevation in meter) at given time by default at epoch 

    Parameters
    ----------
    time_delta : float, optional
        Time passed from the epoch

    Returns
    -------
    tuple[float, float, float]
        (latitude, longitude, elevation in meter)
    &#34;&#34;&#34;

    _satellite = self.get_satellite()
    _satellite.compute(
        str(self.epoch+time_delta),
        epoch=str(self.epoch)
    )
    return math.degrees(_satellite.sublat), math.degrees(_satellite.sublong),  _satellite.elevation</code></pre>
</details>
</dd>
<dt id="LEOCraft.satellite_topology.satellite.LEOSatellite.orbital_period_s"><code class="name flex">
<span>def <span class="ident">orbital_period_s</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates orbital period of the satellite in seconds
Returns</p>
<hr>
<dl>
<dt><code>float</code></dt>
<dd>second(s)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orbital_period_s(self) -&gt; float:
    &#34;&#34;&#34;Calculates orbital period of the satellite in seconds
    Returns
    -------
    float
        second(s)
    &#34;&#34;&#34;

    orbit_radius = self.EARTH_RADIUS_M + self.altitude_m
    return math.sqrt(
        (4 * (math.pi**2) * orbit_radius**3)/(self.G * self.MASS)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="LEOCraft.satellite_topology" href="index.html">LEOCraft.satellite_topology</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite" href="#LEOCraft.satellite_topology.satellite.LEOSatellite">LEOSatellite</a></code></h4>
<ul class="">
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.ARG_OF_PERIGEE_DEGREE" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.ARG_OF_PERIGEE_DEGREE">ARG_OF_PERIGEE_DEGREE</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.EARTH_RADIUS_M" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.EARTH_RADIUS_M">EARTH_RADIUS_M</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.ECCENTRICITY" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.ECCENTRICITY">ECCENTRICITY</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.G" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.G">G</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.MASS" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.MASS">MASS</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.build" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.build">build</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.coverage_cone_radius_m" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.coverage_cone_radius_m">coverage_cone_radius_m</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.get_TLE" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.get_TLE">get_TLE</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.get_satellite" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.get_satellite">get_satellite</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.max_GSL_length_m" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.max_GSL_length_m">max_GSL_length_m</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.max_ISL_length_m" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.max_ISL_length_m">max_ISL_length_m</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.nadir" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.nadir">nadir</a></code></li>
<li><code><a title="LEOCraft.satellite_topology.satellite.LEOSatellite.orbital_period_s" href="#LEOCraft.satellite_topology.satellite.LEOSatellite.orbital_period_s">orbital_period_s</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>