<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>LEOCraft.constellations.constellation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>LEOCraft.constellations.constellation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import concurrent.futures
import json
import multiprocessing as mp
import os
import time
from abc import ABC, abstractmethod

import networkx as nx
from astropy import units as u
from astropy.time import TimeDelta

from LEOCraft.attenuation.fspl import FSPL
from LEOCraft.satellite_topology.LEO_sat_topology import (LEOSatelliteTopology,
                                                          SatelliteInfo)
from LEOCraft.satellite_topology.plus_grid_shell import PlusGridShell
from LEOCraft.user_terminals.ground_station import GroundStation
from LEOCraft.user_terminals.terminal import TerminalCoordinates
from LEOCraft.utilities import ProcessingLog


class Constellation(ABC):
    &#34;Abstract class for the LEO constellations&#34;

    ISL_CAPACITY: float = 50.0
    GSL_CAPACITY: float = 20.0
    k: int = 20

    def __init__(self, name: str, PARALLEL_MODE: bool = True) -&gt; None:
        self.PARALLEL_MODE = PARALLEL_MODE

        self.name = name
        self.ground_stations: GroundStation
        self.shells: list[PlusGridShell] = list()

        self.v = ProcessingLog(self.__class__.__name__)

        # Stores the routes with a key G-X_G-Y
        self.routes: dict[str, list[list[str]]]
        # Stores the flow per link with a key (hop, hop)
        self.link_load: dict[tuple[str, str], set[tuple[str, int]]]
        self.no_path_found: set[str]
        self.k_path_not_found: set[str]

    def set_loss_model(self, model: FSPL | None) -&gt; None:
        &#34;Set path-loss model&#34;
        self.loss_model = model

    def set_time(
        self,
        day: int = 0,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        millisecond: int = 0,
        nanosecond: int = 0
    ) -&gt; None:
        &#34;&#34;&#34;Sets the simulation time, i.e., time passed from the epoch. Default values are zero (0)

        Parameters
        ----------
        day : int, optional
        hour: int, optional
        minute: int, optional
        second: int, optional
        millisecond: int, optional
        nanosecond: int, optional
        &#34;&#34;&#34;
        self.time_delta = self.calculate_time_delta(
            day, hour, minute, second, millisecond, nanosecond
        )

    @staticmethod
    def calculate_time_delta(
        day: int = 0,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        millisecond: int = 0,
        nanosecond: int = 0
    ) -&gt; TimeDelta:
        _time_delta = TimeDelta(nanosecond * u.nanosecond)
        _time_delta += TimeDelta(millisecond * u.millisecond)
        _time_delta += TimeDelta(second * u.second)
        _time_delta += TimeDelta(minute * u.minute)
        _time_delta += TimeDelta(hour * u.hour)
        _time_delta += TimeDelta(day * u.day)
        return _time_delta

    def add_ground_stations(self, ground_stations: GroundStation) -&gt; None:
        &#34;&#34;&#34;Adds ground stations to the constellation

        Parameters
        ------
        ground_stations: GroundStation
            Instance of GroundStation with all the terminals
        &#34;&#34;&#34;
        self.ground_stations = ground_stations

    def add_shells(self, shell: LEOSatelliteTopology) -&gt; None:
        &#34;&#34;&#34;Adds LEO satellite shell to the constellation

        Parameters
        ------
        shell: LEOSatelliteTopology
            Instance of LEOSatelliteTopology with LEO satellite topology (satellites and ISLs)
        &#34;&#34;&#34;
        assert shell.id == len(self.shells), &#39;Shell ID error&#39;
        self.shells.append(shell)

    def build(self) -&gt; None:
        &#34;&#34;&#34;Build the constellation
        - Build ground stations
        - Build Shells
        - Generate GSLs
        - Computes satellites coverage
        &#34;&#34;&#34;

        assert len(self.shells) &gt; 0, &#39;Atleast one shell required.&#39;

        self.v.log(&#39;Building ground stations...&#39;)
        self.ground_stations.build()

        self.v.log(&#39;Building shells...&#39;)
        for shell_id, shell in enumerate(self.shells):
            self.v.rlog(f&#39;Processing...  ({shell_id+1}/{len(self.shells)})&#39;)
            shell.build_satellites()
            shell.build_ISLs()
        self.v.clr()

        self.v.log(&#39;Building ground to satellite links...&#39;)
        # Records of user terminals under satellite coverage
        self.sat_coverage: dict[str, set[str]] = dict()
        # Ground to satellite link records
        # List index is the ground station terminal index
        self.gsls = [None]*len(self.ground_stations.terminals)

        start_time = time.perf_counter()

        if self.PARALLEL_MODE:
            self._pbuild_gsls()
        else:
            self._sbuild_gsls()

        self.v.clr()
        end_time = time.perf_counter()
        self.v.log(
            f&#39;&#39;&#39;GSLs generated in: {round((end_time-start_time)/60, 2)}m&#39;&#39;&#39;
        )

    def _pbuild_gsls(self) -&gt; None:
        &#34;Compute GSLs in parallel mode&#34;
        with concurrent.futures.ProcessPoolExecutor(mp_context=mp.get_context(&#39;fork&#39;)) as executor:
            gsl_compute = list()
            for gid, gs in enumerate(self.ground_stations.terminals):
                self.gsls[gid] = set()
                self.v.rlog(
                    f&#39;&#39;&#39;Processing GSLs...  ({
                        gid+1}/{len(self.ground_stations.terminals)})&#39;&#39;&#39;
                )

                # For one terminal computing each shell in parallel
                for shell in self.shells:

                    gsl_compute.append(
                        executor.submit(
                            shell.get_satellites_in_range,
                            gs, gid, self.time_delta
                        )
                    )

            compute_count = 0
            for compute in concurrent.futures.as_completed(gsl_compute):
                compute_count += 1
                self.v.rlog(
                    f&#39;&#39;&#39;Processing GSLs completed...   {
                        round(compute_count/len(gsl_compute)*100)}%   &#39;&#39;&#39;
                )

                # Collecting results and adding list of GSLs and satellite coverage
                rgid, visible_sats, sats_range_m = compute.result()
                for sat_name, distance_m in zip(visible_sats, sats_range_m):
                    self._add_sat_coverage(
                        sat_name, self.ground_stations.encode_name(rgid)
                    )
                    self.gsls[rgid].add((sat_name, distance_m))

    def _sbuild_gsls(self) -&gt; None:
        &#34;Compute GSLs in serial mode&#34;
        for gid, gs in enumerate(self.ground_stations.terminals):
            self.gsls[gid] = set()
            self.v.rlog(
                f&#39;&#39;&#39;Processing GSLs...  ({
                    gid+1}/{len(self.ground_stations.terminals)})&#39;&#39;&#39;
            )

            for shell in self.shells:
                _, visible_sats, sats_range_m = shell.get_satellites_in_range(
                    gs, gid, self.time_delta
                )
                for sat_name, distance_m in zip(visible_sats, sats_range_m):
                    self.gsls[gid].add((sat_name, distance_m))
                    self._add_sat_coverage(
                        sat_name, self.ground_stations.encode_name(gid)
                    )

    def _add_sat_coverage(self, sat_name: str, gs_name: str) -&gt; None:
        &#34;Adds ground station name under the coverage of a satellite&#34;
        if sat_name not in self.sat_coverage:
            self.sat_coverage[sat_name] = set()
        self.sat_coverage[sat_name].add(gs_name)

    def _add_satellites_from_shell(self, shell: LEOSatelliteTopology) -&gt; None:
        &#34;Adds encoded satellite name into N/W graph&#34;
        for sid in range(len(shell.satellites)):
            self.sat_net_graph.add_node(shell.encode_sat_name(sid))

    def _add_ISLs_from_shell(self, shell: LEOSatelliteTopology) -&gt; None:
        for sid_a, sid_b in (shell.isls):
            distance_m, in_ISL_range = shell.distance_between_sat_m(
                sid_a, sid_b, self.time_delta
            )

            if not in_ISL_range:
                raise ValueError(f&#34;&#34;&#34;The distance between two satellites ({sid_a} and {sid_b}) with an ISL exceeded the maximum ISL length ({
                                 distance_m/1000}km &gt; {shell.satellites[sid_a].max_ISL_length_m()/1000}km at time_delta={self.time_delta})&#34;&#34;&#34;)

            self.sat_net_graph.add_edge(
                shell.encode_sat_name(sid_a),
                shell.encode_sat_name(sid_b),
                weight=distance_m,
                capacity=self.ISL_CAPACITY
            )

    def create_network_graph(self) -&gt; None:
        &#34;&#34;&#34;Create network graph using Networkx
        - Nodes:
            - Ground stations
            - Satellites
        - Edges:
            - GSLs
            - ISLs
        - Edge attributes
            - weight: distance in meters
            - capacity: link_bandwidth in Gbps
        &#34;&#34;&#34;

        # Satellite network graph
        self.sat_net_graph = nx.Graph()

        # Add satellites from each shell
        self.v.log(&#39;Adding satellites into network graph...&#39;)
        for shell in self.shells:
            self._add_satellites_from_shell(shell)

        # Add ISLs from each shell
        self.v.log(&#39;Adding ISLs into network graph...&#39;)
        for shell_id, shell in enumerate(self.shells):
            self.v.rlog(f&#39;Processing... ({shell_id}/{len(self.shells)})&#39;)
            self._add_ISLs_from_shell(shell)
        self.v.clr()

    def connect_ground_station(self, *gs_names: tuple[str]) -&gt; None:
        &#34;&#34;&#34;Adds ground to satellites links to network graph

        Parameters
        -------
        gs_names: tuple[str]
            Tuple of ground station names (&#39;G-X&#39;,&#39;G-Y&#39;)
        &#34;&#34;&#34;

        for gs_name in gs_names:
            gid = self.ground_stations.decode_name(gs_name)
            for sat_name, distance_m in self.gsls[gid]:
                # When pathloss model is available
                if self.loss_model:
                    link_bandwidth = self.loss_model.data_rate_bps(
                        distance_m, len(self.sat_coverage[sat_name])
                    )/1000000000

                # When pathloss model is not available
                else:
                    link_bandwidth = round(
                        self.GSL_CAPACITY/len(self.sat_coverage[sat_name])
                    )

                self.sat_net_graph.add_edge(
                    gs_name, sat_name, weight=distance_m, capacity=link_bandwidth
                )

    def disconnect_ground_station(self, *gs_names: tuple[str]) -&gt; None:
        &#34;&#34;&#34;Remove ground to satellites links from network graph

        Parameters
        -------
        gs_names: tuple[str]
            Tuple of ground station names (&#39;G-X&#39;,&#39;G-Y&#39;)
        &#34;&#34;&#34;

        for gs_name in gs_names:
            gid = self.ground_stations.decode_name(gs_name)
            for sat_name, _ in self.gsls[gid]:
                self.sat_net_graph.remove_edge(gs_name, sat_name)

    @abstractmethod
    def generate_routes(self, k: int = 1) -&gt; None:
        &#34;&#34;&#34;Generate K shortest routes from all terminals to all terminals. \n
        - Generate routes in dict with key: `G-X_G-Y`
        - Generate link load dict (number of flow through each link) with key: `tuple(hop, hop)`
        - Records no path found between two GS: set(flow)
        - Records if K path not found between two GS: set(flow, # flow found)

        Parameters
        --------
        k: int
            Number of shortest routes terminal to terminal
        &#34;&#34;&#34;
        pass

    def _add_linkload(self, flow_via_route: tuple[str, int], edge: tuple[str, str]) -&gt; None:
        &#34;&#34;&#34;Add flow details going through a link (edge)

        Parameters
        -------
        flow_via_route: tuple[str, int]
            Flow key (G-X_G-Y) and route index (k) i.e., (G-X_G-Y, k)

        edge: tuple[str, str]
            ISL of GSL link i,e, (G-X, S0-Y)
        &#34;&#34;&#34;

        # For new edge
        if edge not in self.link_load:
            self.link_load[edge] = set()

        if flow_via_route not in self.link_load[edge]:
            self.link_load[edge].add(flow_via_route)

    def _add_route(self, compute_status: bool, flow: str, k_path: list[list[str]]) -&gt; None:
        &#39;&#39;&#39;Post processing of routes routes after  compute

        Parameters
        --------
        compute_status: bool
            Compute status
        flow: str
            Flow name (G-X_G-Y) or (G-X_F-Y)
        k_path: list[list[str]]
            List of K routes
        &#39;&#39;&#39;
        # In case no path found
        if False == compute_status:
            self.no_path_found.add(flow)

        # In case K path not found
        # Record the flow and number of path (&lt; k) found
        if compute_status and len(k_path) != self.k:
            self.k_path_not_found.add(f&#39;{flow},{len(k_path)}&#39;)
            return

        # Storing the routes
        self.routes[flow] = k_path

        # Recording total flows passing through each link
        for k_index, path in enumerate(k_path):
            flow_via_route = (flow, k_index)

            # Two end links (ground station to satellite)
            self._add_linkload(flow_via_route, (path[0], path[1]))
            self._add_linkload(flow_via_route, (path[-1], path[-2]))

            # All intermmidiate links
            for hop in range(1, len(path)-2):
                # Adding load in order
                if path[hop] &lt; path[hop+1]:
                    self._add_linkload(
                        flow_via_route, (path[hop], path[hop+1])
                    )
                else:
                    self._add_linkload(
                        flow_via_route, (path[hop+1], path[hop])
                    )

    def link_capacity(self, node_a: str, node_b: str) -&gt; float:
        &#34;&#34;&#34;Get the capacity (Gbps) of a link

        Parameters
        -------
        node_a: str
            Satellite/ground station name  in network graph
        node_b: str
            Satellite/ground station name in network graph

        Returns
        -------
        float
            Data rate in Gbps
        &#34;&#34;&#34;
        return self.sat_net_graph[node_a][node_b][&#34;capacity&#34;]

    def link_length(self, node_a: str, node_b: str) -&gt; float:
        &#34;&#34;&#34;Get the length (meters) of a link

        Parameters
        -------
        node_a: str
            Satellite/ground station name  in network graph
        node_b: str
            Satellite/ground station name  in network graph

        Returns
        -------
        float
            Length in meters
        &#34;&#34;&#34;
        return self.sat_net_graph[node_a][node_b][&#34;weight&#34;]

    def sat_info(self, sat_name: str) -&gt; SatelliteInfo:
        &#34;&#34;&#34;Get satellite information at current time delta

        Parameters
        ---------
        sat_name: str
            Satellite name

        Returns
        ---------
        tuple[int, int, tuple[float, float]]
            Shell ID, Satellite ID, (lat, long)
        &#34;&#34;&#34;

        shell_id, sid = LEOSatelliteTopology.decode_sat_name(sat_name)
        return self.shells[shell_id].build_sat_info(sid, self.time_delta)

    def gs_info(self, gs_name: str) -&gt; tuple[int, TerminalCoordinates]:
        &#34;&#34;&#34;Get ground station information

        Parameters
        ---------
        gs_name: str
            Ground station name

        Returns
        ---------
        tuple[int, TerminalCoordinates]
            Ground station ID, TerminalCoordinates dataclass object
        &#34;&#34;&#34;

        gid = self.ground_stations.decode_name(gs_name)
        return gid, self.ground_stations.terminals[gid]

    def _create_export_dir(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#39;Create directory for time delta inside given path (default current directory)&#39;
        dir = f&#39;{prefix_path}/{self.time_delta}&#39;
        if not os.path.isdir(dir):
            os.makedirs(dir, exist_ok=True)
        return dir

    def _write_text_file(self, content: set[str], path_filename: str) -&gt; str:
        &#39;Write a text file separated by new line&#39;
        with open(path_filename, &#34;w&#34;) as text_file:
            for line in content:
                text_file.write(f&#34;{line}\n&#34;)

        return path_filename

    def _write_json_file(self, content: dict, path_filename: str) -&gt; str:
        &#39;Write dict into a JSON file&#39;
        with open(path_filename, &#39;w&#39;) as json_file:
            json_file.write(json.dumps(content))
        return path_filename

    def export_routes(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#34;&#34;&#34;Write routes into a JSON file inside time delta at given path (default current directory)

        Parameters
        ----------
        prefix_path: str, optional
            File directory

        Returns
        -------
        str
            File name 
        &#34;&#34;&#34;
        # Create directory with time delta
        dir = self._create_export_dir(prefix_path)
        filename = f&#39;{dir}/{self.name}_routes.json&#39;

        # Write JSON file
        with open(filename, &#39;w&#39;) as json_file:
            json_file.write(json.dumps(self.routes))

        return filename

    def export_no_path_found(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#34;&#34;&#34;Write flows with no path into a TXT file inside time delta at given path (default current directory)

        Parameters
        ----------
        prefix_path: str, optional
            File directory

        Returns
        -------
        str
            File name 
        &#34;&#34;&#34;
        # Create directory with time delta
        dir = self._create_export_dir(prefix_path)
        filename = f&#39;{dir}/{self.name}_no_path_found.txt&#39;
        return self._write_text_file(self.no_path_found, filename)

    def export_k_path_not_found(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#34;&#34;&#34;Write flows with less then k path into a TXT file inside time delta at given path (default current directory)

        Parameters
        ----------
        prefix_path: str, optional
            File directory

        Returns
        -------
        str
            File name 
        &#34;&#34;&#34;
        # Create directory with time delta
        dir = self._create_export_dir(prefix_path)
        filename = f&#39;{dir}/{self.name}_k_path_not_found.txt&#39;
        return self._write_text_file(self.k_path_not_found, filename)

    def export_gsls(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#34;&#34;&#34;Write GSLs into a JSON file inside time delta at given path (default current directory)

        Parameters
        ----------
        prefix_path: str, optional
            File directory

        Returns
        -------
        str
            File name 
        &#34;&#34;&#34;
        # Create directory with time delta
        dir = self._create_export_dir(prefix_path)
        filename = f&#39;{dir}/{self.name}_gsls.json&#39;

        # Convert GSLs in a to dict
        json_data = {}
        for gid, visibility in enumerate(self.gsls):
            json_data[self.ground_stations.encode_name(gid)] = list(visibility)
        return self._write_json_file(json_data, filename)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="LEOCraft.constellations.constellation.Constellation"><code class="flex name class">
<span>class <span class="ident">Constellation</span></span>
<span>(</span><span>name: str, PARALLEL_MODE: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class for the LEO constellations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Constellation(ABC):
    &#34;Abstract class for the LEO constellations&#34;

    ISL_CAPACITY: float = 50.0
    GSL_CAPACITY: float = 20.0
    k: int = 20

    def __init__(self, name: str, PARALLEL_MODE: bool = True) -&gt; None:
        self.PARALLEL_MODE = PARALLEL_MODE

        self.name = name
        self.ground_stations: GroundStation
        self.shells: list[PlusGridShell] = list()

        self.v = ProcessingLog(self.__class__.__name__)

        # Stores the routes with a key G-X_G-Y
        self.routes: dict[str, list[list[str]]]
        # Stores the flow per link with a key (hop, hop)
        self.link_load: dict[tuple[str, str], set[tuple[str, int]]]
        self.no_path_found: set[str]
        self.k_path_not_found: set[str]

    def set_loss_model(self, model: FSPL | None) -&gt; None:
        &#34;Set path-loss model&#34;
        self.loss_model = model

    def set_time(
        self,
        day: int = 0,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        millisecond: int = 0,
        nanosecond: int = 0
    ) -&gt; None:
        &#34;&#34;&#34;Sets the simulation time, i.e., time passed from the epoch. Default values are zero (0)

        Parameters
        ----------
        day : int, optional
        hour: int, optional
        minute: int, optional
        second: int, optional
        millisecond: int, optional
        nanosecond: int, optional
        &#34;&#34;&#34;
        self.time_delta = self.calculate_time_delta(
            day, hour, minute, second, millisecond, nanosecond
        )

    @staticmethod
    def calculate_time_delta(
        day: int = 0,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        millisecond: int = 0,
        nanosecond: int = 0
    ) -&gt; TimeDelta:
        _time_delta = TimeDelta(nanosecond * u.nanosecond)
        _time_delta += TimeDelta(millisecond * u.millisecond)
        _time_delta += TimeDelta(second * u.second)
        _time_delta += TimeDelta(minute * u.minute)
        _time_delta += TimeDelta(hour * u.hour)
        _time_delta += TimeDelta(day * u.day)
        return _time_delta

    def add_ground_stations(self, ground_stations: GroundStation) -&gt; None:
        &#34;&#34;&#34;Adds ground stations to the constellation

        Parameters
        ------
        ground_stations: GroundStation
            Instance of GroundStation with all the terminals
        &#34;&#34;&#34;
        self.ground_stations = ground_stations

    def add_shells(self, shell: LEOSatelliteTopology) -&gt; None:
        &#34;&#34;&#34;Adds LEO satellite shell to the constellation

        Parameters
        ------
        shell: LEOSatelliteTopology
            Instance of LEOSatelliteTopology with LEO satellite topology (satellites and ISLs)
        &#34;&#34;&#34;
        assert shell.id == len(self.shells), &#39;Shell ID error&#39;
        self.shells.append(shell)

    def build(self) -&gt; None:
        &#34;&#34;&#34;Build the constellation
        - Build ground stations
        - Build Shells
        - Generate GSLs
        - Computes satellites coverage
        &#34;&#34;&#34;

        assert len(self.shells) &gt; 0, &#39;Atleast one shell required.&#39;

        self.v.log(&#39;Building ground stations...&#39;)
        self.ground_stations.build()

        self.v.log(&#39;Building shells...&#39;)
        for shell_id, shell in enumerate(self.shells):
            self.v.rlog(f&#39;Processing...  ({shell_id+1}/{len(self.shells)})&#39;)
            shell.build_satellites()
            shell.build_ISLs()
        self.v.clr()

        self.v.log(&#39;Building ground to satellite links...&#39;)
        # Records of user terminals under satellite coverage
        self.sat_coverage: dict[str, set[str]] = dict()
        # Ground to satellite link records
        # List index is the ground station terminal index
        self.gsls = [None]*len(self.ground_stations.terminals)

        start_time = time.perf_counter()

        if self.PARALLEL_MODE:
            self._pbuild_gsls()
        else:
            self._sbuild_gsls()

        self.v.clr()
        end_time = time.perf_counter()
        self.v.log(
            f&#39;&#39;&#39;GSLs generated in: {round((end_time-start_time)/60, 2)}m&#39;&#39;&#39;
        )

    def _pbuild_gsls(self) -&gt; None:
        &#34;Compute GSLs in parallel mode&#34;
        with concurrent.futures.ProcessPoolExecutor(mp_context=mp.get_context(&#39;fork&#39;)) as executor:
            gsl_compute = list()
            for gid, gs in enumerate(self.ground_stations.terminals):
                self.gsls[gid] = set()
                self.v.rlog(
                    f&#39;&#39;&#39;Processing GSLs...  ({
                        gid+1}/{len(self.ground_stations.terminals)})&#39;&#39;&#39;
                )

                # For one terminal computing each shell in parallel
                for shell in self.shells:

                    gsl_compute.append(
                        executor.submit(
                            shell.get_satellites_in_range,
                            gs, gid, self.time_delta
                        )
                    )

            compute_count = 0
            for compute in concurrent.futures.as_completed(gsl_compute):
                compute_count += 1
                self.v.rlog(
                    f&#39;&#39;&#39;Processing GSLs completed...   {
                        round(compute_count/len(gsl_compute)*100)}%   &#39;&#39;&#39;
                )

                # Collecting results and adding list of GSLs and satellite coverage
                rgid, visible_sats, sats_range_m = compute.result()
                for sat_name, distance_m in zip(visible_sats, sats_range_m):
                    self._add_sat_coverage(
                        sat_name, self.ground_stations.encode_name(rgid)
                    )
                    self.gsls[rgid].add((sat_name, distance_m))

    def _sbuild_gsls(self) -&gt; None:
        &#34;Compute GSLs in serial mode&#34;
        for gid, gs in enumerate(self.ground_stations.terminals):
            self.gsls[gid] = set()
            self.v.rlog(
                f&#39;&#39;&#39;Processing GSLs...  ({
                    gid+1}/{len(self.ground_stations.terminals)})&#39;&#39;&#39;
            )

            for shell in self.shells:
                _, visible_sats, sats_range_m = shell.get_satellites_in_range(
                    gs, gid, self.time_delta
                )
                for sat_name, distance_m in zip(visible_sats, sats_range_m):
                    self.gsls[gid].add((sat_name, distance_m))
                    self._add_sat_coverage(
                        sat_name, self.ground_stations.encode_name(gid)
                    )

    def _add_sat_coverage(self, sat_name: str, gs_name: str) -&gt; None:
        &#34;Adds ground station name under the coverage of a satellite&#34;
        if sat_name not in self.sat_coverage:
            self.sat_coverage[sat_name] = set()
        self.sat_coverage[sat_name].add(gs_name)

    def _add_satellites_from_shell(self, shell: LEOSatelliteTopology) -&gt; None:
        &#34;Adds encoded satellite name into N/W graph&#34;
        for sid in range(len(shell.satellites)):
            self.sat_net_graph.add_node(shell.encode_sat_name(sid))

    def _add_ISLs_from_shell(self, shell: LEOSatelliteTopology) -&gt; None:
        for sid_a, sid_b in (shell.isls):
            distance_m, in_ISL_range = shell.distance_between_sat_m(
                sid_a, sid_b, self.time_delta
            )

            if not in_ISL_range:
                raise ValueError(f&#34;&#34;&#34;The distance between two satellites ({sid_a} and {sid_b}) with an ISL exceeded the maximum ISL length ({
                                 distance_m/1000}km &gt; {shell.satellites[sid_a].max_ISL_length_m()/1000}km at time_delta={self.time_delta})&#34;&#34;&#34;)

            self.sat_net_graph.add_edge(
                shell.encode_sat_name(sid_a),
                shell.encode_sat_name(sid_b),
                weight=distance_m,
                capacity=self.ISL_CAPACITY
            )

    def create_network_graph(self) -&gt; None:
        &#34;&#34;&#34;Create network graph using Networkx
        - Nodes:
            - Ground stations
            - Satellites
        - Edges:
            - GSLs
            - ISLs
        - Edge attributes
            - weight: distance in meters
            - capacity: link_bandwidth in Gbps
        &#34;&#34;&#34;

        # Satellite network graph
        self.sat_net_graph = nx.Graph()

        # Add satellites from each shell
        self.v.log(&#39;Adding satellites into network graph...&#39;)
        for shell in self.shells:
            self._add_satellites_from_shell(shell)

        # Add ISLs from each shell
        self.v.log(&#39;Adding ISLs into network graph...&#39;)
        for shell_id, shell in enumerate(self.shells):
            self.v.rlog(f&#39;Processing... ({shell_id}/{len(self.shells)})&#39;)
            self._add_ISLs_from_shell(shell)
        self.v.clr()

    def connect_ground_station(self, *gs_names: tuple[str]) -&gt; None:
        &#34;&#34;&#34;Adds ground to satellites links to network graph

        Parameters
        -------
        gs_names: tuple[str]
            Tuple of ground station names (&#39;G-X&#39;,&#39;G-Y&#39;)
        &#34;&#34;&#34;

        for gs_name in gs_names:
            gid = self.ground_stations.decode_name(gs_name)
            for sat_name, distance_m in self.gsls[gid]:
                # When pathloss model is available
                if self.loss_model:
                    link_bandwidth = self.loss_model.data_rate_bps(
                        distance_m, len(self.sat_coverage[sat_name])
                    )/1000000000

                # When pathloss model is not available
                else:
                    link_bandwidth = round(
                        self.GSL_CAPACITY/len(self.sat_coverage[sat_name])
                    )

                self.sat_net_graph.add_edge(
                    gs_name, sat_name, weight=distance_m, capacity=link_bandwidth
                )

    def disconnect_ground_station(self, *gs_names: tuple[str]) -&gt; None:
        &#34;&#34;&#34;Remove ground to satellites links from network graph

        Parameters
        -------
        gs_names: tuple[str]
            Tuple of ground station names (&#39;G-X&#39;,&#39;G-Y&#39;)
        &#34;&#34;&#34;

        for gs_name in gs_names:
            gid = self.ground_stations.decode_name(gs_name)
            for sat_name, _ in self.gsls[gid]:
                self.sat_net_graph.remove_edge(gs_name, sat_name)

    @abstractmethod
    def generate_routes(self, k: int = 1) -&gt; None:
        &#34;&#34;&#34;Generate K shortest routes from all terminals to all terminals. \n
        - Generate routes in dict with key: `G-X_G-Y`
        - Generate link load dict (number of flow through each link) with key: `tuple(hop, hop)`
        - Records no path found between two GS: set(flow)
        - Records if K path not found between two GS: set(flow, # flow found)

        Parameters
        --------
        k: int
            Number of shortest routes terminal to terminal
        &#34;&#34;&#34;
        pass

    def _add_linkload(self, flow_via_route: tuple[str, int], edge: tuple[str, str]) -&gt; None:
        &#34;&#34;&#34;Add flow details going through a link (edge)

        Parameters
        -------
        flow_via_route: tuple[str, int]
            Flow key (G-X_G-Y) and route index (k) i.e., (G-X_G-Y, k)

        edge: tuple[str, str]
            ISL of GSL link i,e, (G-X, S0-Y)
        &#34;&#34;&#34;

        # For new edge
        if edge not in self.link_load:
            self.link_load[edge] = set()

        if flow_via_route not in self.link_load[edge]:
            self.link_load[edge].add(flow_via_route)

    def _add_route(self, compute_status: bool, flow: str, k_path: list[list[str]]) -&gt; None:
        &#39;&#39;&#39;Post processing of routes routes after  compute

        Parameters
        --------
        compute_status: bool
            Compute status
        flow: str
            Flow name (G-X_G-Y) or (G-X_F-Y)
        k_path: list[list[str]]
            List of K routes
        &#39;&#39;&#39;
        # In case no path found
        if False == compute_status:
            self.no_path_found.add(flow)

        # In case K path not found
        # Record the flow and number of path (&lt; k) found
        if compute_status and len(k_path) != self.k:
            self.k_path_not_found.add(f&#39;{flow},{len(k_path)}&#39;)
            return

        # Storing the routes
        self.routes[flow] = k_path

        # Recording total flows passing through each link
        for k_index, path in enumerate(k_path):
            flow_via_route = (flow, k_index)

            # Two end links (ground station to satellite)
            self._add_linkload(flow_via_route, (path[0], path[1]))
            self._add_linkload(flow_via_route, (path[-1], path[-2]))

            # All intermmidiate links
            for hop in range(1, len(path)-2):
                # Adding load in order
                if path[hop] &lt; path[hop+1]:
                    self._add_linkload(
                        flow_via_route, (path[hop], path[hop+1])
                    )
                else:
                    self._add_linkload(
                        flow_via_route, (path[hop+1], path[hop])
                    )

    def link_capacity(self, node_a: str, node_b: str) -&gt; float:
        &#34;&#34;&#34;Get the capacity (Gbps) of a link

        Parameters
        -------
        node_a: str
            Satellite/ground station name  in network graph
        node_b: str
            Satellite/ground station name in network graph

        Returns
        -------
        float
            Data rate in Gbps
        &#34;&#34;&#34;
        return self.sat_net_graph[node_a][node_b][&#34;capacity&#34;]

    def link_length(self, node_a: str, node_b: str) -&gt; float:
        &#34;&#34;&#34;Get the length (meters) of a link

        Parameters
        -------
        node_a: str
            Satellite/ground station name  in network graph
        node_b: str
            Satellite/ground station name  in network graph

        Returns
        -------
        float
            Length in meters
        &#34;&#34;&#34;
        return self.sat_net_graph[node_a][node_b][&#34;weight&#34;]

    def sat_info(self, sat_name: str) -&gt; SatelliteInfo:
        &#34;&#34;&#34;Get satellite information at current time delta

        Parameters
        ---------
        sat_name: str
            Satellite name

        Returns
        ---------
        tuple[int, int, tuple[float, float]]
            Shell ID, Satellite ID, (lat, long)
        &#34;&#34;&#34;

        shell_id, sid = LEOSatelliteTopology.decode_sat_name(sat_name)
        return self.shells[shell_id].build_sat_info(sid, self.time_delta)

    def gs_info(self, gs_name: str) -&gt; tuple[int, TerminalCoordinates]:
        &#34;&#34;&#34;Get ground station information

        Parameters
        ---------
        gs_name: str
            Ground station name

        Returns
        ---------
        tuple[int, TerminalCoordinates]
            Ground station ID, TerminalCoordinates dataclass object
        &#34;&#34;&#34;

        gid = self.ground_stations.decode_name(gs_name)
        return gid, self.ground_stations.terminals[gid]

    def _create_export_dir(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#39;Create directory for time delta inside given path (default current directory)&#39;
        dir = f&#39;{prefix_path}/{self.time_delta}&#39;
        if not os.path.isdir(dir):
            os.makedirs(dir, exist_ok=True)
        return dir

    def _write_text_file(self, content: set[str], path_filename: str) -&gt; str:
        &#39;Write a text file separated by new line&#39;
        with open(path_filename, &#34;w&#34;) as text_file:
            for line in content:
                text_file.write(f&#34;{line}\n&#34;)

        return path_filename

    def _write_json_file(self, content: dict, path_filename: str) -&gt; str:
        &#39;Write dict into a JSON file&#39;
        with open(path_filename, &#39;w&#39;) as json_file:
            json_file.write(json.dumps(content))
        return path_filename

    def export_routes(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#34;&#34;&#34;Write routes into a JSON file inside time delta at given path (default current directory)

        Parameters
        ----------
        prefix_path: str, optional
            File directory

        Returns
        -------
        str
            File name 
        &#34;&#34;&#34;
        # Create directory with time delta
        dir = self._create_export_dir(prefix_path)
        filename = f&#39;{dir}/{self.name}_routes.json&#39;

        # Write JSON file
        with open(filename, &#39;w&#39;) as json_file:
            json_file.write(json.dumps(self.routes))

        return filename

    def export_no_path_found(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#34;&#34;&#34;Write flows with no path into a TXT file inside time delta at given path (default current directory)

        Parameters
        ----------
        prefix_path: str, optional
            File directory

        Returns
        -------
        str
            File name 
        &#34;&#34;&#34;
        # Create directory with time delta
        dir = self._create_export_dir(prefix_path)
        filename = f&#39;{dir}/{self.name}_no_path_found.txt&#39;
        return self._write_text_file(self.no_path_found, filename)

    def export_k_path_not_found(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#34;&#34;&#34;Write flows with less then k path into a TXT file inside time delta at given path (default current directory)

        Parameters
        ----------
        prefix_path: str, optional
            File directory

        Returns
        -------
        str
            File name 
        &#34;&#34;&#34;
        # Create directory with time delta
        dir = self._create_export_dir(prefix_path)
        filename = f&#39;{dir}/{self.name}_k_path_not_found.txt&#39;
        return self._write_text_file(self.k_path_not_found, filename)

    def export_gsls(self, prefix_path: str = &#39;.&#39;) -&gt; str:
        &#34;&#34;&#34;Write GSLs into a JSON file inside time delta at given path (default current directory)

        Parameters
        ----------
        prefix_path: str, optional
            File directory

        Returns
        -------
        str
            File name 
        &#34;&#34;&#34;
        # Create directory with time delta
        dir = self._create_export_dir(prefix_path)
        filename = f&#39;{dir}/{self.name}_gsls.json&#39;

        # Convert GSLs in a to dict
        json_data = {}
        for gid, visibility in enumerate(self.gsls):
            json_data[self.ground_stations.encode_name(gid)] = list(visibility)
        return self._write_json_file(json_data, filename)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="LEOCraft.constellations.LEO_aviation_constellation.LEOAviationConstellation" href="LEO_aviation_constellation.html#LEOCraft.constellations.LEO_aviation_constellation.LEOAviationConstellation">LEOAviationConstellation</a></li>
<li><a title="LEOCraft.constellations.LEO_constellation.LEOConstellation" href="LEO_constellation.html#LEOCraft.constellations.LEO_constellation.LEOConstellation">LEOConstellation</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="LEOCraft.constellations.constellation.Constellation.GSL_CAPACITY"><code class="name">var <span class="ident">GSL_CAPACITY</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.ISL_CAPACITY"><code class="name">var <span class="ident">ISL_CAPACITY</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.k"><code class="name">var <span class="ident">k</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="LEOCraft.constellations.constellation.Constellation.calculate_time_delta"><code class="name flex">
<span>def <span class="ident">calculate_time_delta</span></span>(<span>day: int = 0, hour: int = 0, minute: int = 0, second: int = 0, millisecond: int = 0, nanosecond: int = 0) ‑> astropy.time.core.TimeDelta</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calculate_time_delta(
    day: int = 0,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    millisecond: int = 0,
    nanosecond: int = 0
) -&gt; TimeDelta:
    _time_delta = TimeDelta(nanosecond * u.nanosecond)
    _time_delta += TimeDelta(millisecond * u.millisecond)
    _time_delta += TimeDelta(second * u.second)
    _time_delta += TimeDelta(minute * u.minute)
    _time_delta += TimeDelta(hour * u.hour)
    _time_delta += TimeDelta(day * u.day)
    return _time_delta</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="LEOCraft.constellations.constellation.Constellation.add_ground_stations"><code class="name flex">
<span>def <span class="ident">add_ground_stations</span></span>(<span>self, ground_stations: <a title="LEOCraft.user_terminals.ground_station.GroundStation" href="../user_terminals/ground_station.html#LEOCraft.user_terminals.ground_station.GroundStation">GroundStation</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Adds ground stations to the constellation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ground_stations</code></strong> :&ensp;<code>GroundStation</code></dt>
<dd>Instance of GroundStation with all the terminals</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ground_stations(self, ground_stations: GroundStation) -&gt; None:
    &#34;&#34;&#34;Adds ground stations to the constellation

    Parameters
    ------
    ground_stations: GroundStation
        Instance of GroundStation with all the terminals
    &#34;&#34;&#34;
    self.ground_stations = ground_stations</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.add_shells"><code class="name flex">
<span>def <span class="ident">add_shells</span></span>(<span>self, shell: <a title="LEOCraft.satellite_topology.LEO_sat_topology.LEOSatelliteTopology" href="../satellite_topology/LEO_sat_topology.html#LEOCraft.satellite_topology.LEO_sat_topology.LEOSatelliteTopology">LEOSatelliteTopology</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Adds LEO satellite shell to the constellation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shell</code></strong> :&ensp;<code>LEOSatelliteTopology</code></dt>
<dd>Instance of LEOSatelliteTopology with LEO satellite topology (satellites and ISLs)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_shells(self, shell: LEOSatelliteTopology) -&gt; None:
    &#34;&#34;&#34;Adds LEO satellite shell to the constellation

    Parameters
    ------
    shell: LEOSatelliteTopology
        Instance of LEOSatelliteTopology with LEO satellite topology (satellites and ISLs)
    &#34;&#34;&#34;
    assert shell.id == len(self.shells), &#39;Shell ID error&#39;
    self.shells.append(shell)</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Build the constellation
- Build ground stations
- Build Shells
- Generate GSLs
- Computes satellites coverage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self) -&gt; None:
    &#34;&#34;&#34;Build the constellation
    - Build ground stations
    - Build Shells
    - Generate GSLs
    - Computes satellites coverage
    &#34;&#34;&#34;

    assert len(self.shells) &gt; 0, &#39;Atleast one shell required.&#39;

    self.v.log(&#39;Building ground stations...&#39;)
    self.ground_stations.build()

    self.v.log(&#39;Building shells...&#39;)
    for shell_id, shell in enumerate(self.shells):
        self.v.rlog(f&#39;Processing...  ({shell_id+1}/{len(self.shells)})&#39;)
        shell.build_satellites()
        shell.build_ISLs()
    self.v.clr()

    self.v.log(&#39;Building ground to satellite links...&#39;)
    # Records of user terminals under satellite coverage
    self.sat_coverage: dict[str, set[str]] = dict()
    # Ground to satellite link records
    # List index is the ground station terminal index
    self.gsls = [None]*len(self.ground_stations.terminals)

    start_time = time.perf_counter()

    if self.PARALLEL_MODE:
        self._pbuild_gsls()
    else:
        self._sbuild_gsls()

    self.v.clr()
    end_time = time.perf_counter()
    self.v.log(
        f&#39;&#39;&#39;GSLs generated in: {round((end_time-start_time)/60, 2)}m&#39;&#39;&#39;
    )</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.connect_ground_station"><code class="name flex">
<span>def <span class="ident">connect_ground_station</span></span>(<span>self, *gs_names: tuple[str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Adds ground to satellites links to network graph</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gs_names</code></strong> :&ensp;<code>tuple[str]</code></dt>
<dd>Tuple of ground station names ('G-X','G-Y')</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_ground_station(self, *gs_names: tuple[str]) -&gt; None:
    &#34;&#34;&#34;Adds ground to satellites links to network graph

    Parameters
    -------
    gs_names: tuple[str]
        Tuple of ground station names (&#39;G-X&#39;,&#39;G-Y&#39;)
    &#34;&#34;&#34;

    for gs_name in gs_names:
        gid = self.ground_stations.decode_name(gs_name)
        for sat_name, distance_m in self.gsls[gid]:
            # When pathloss model is available
            if self.loss_model:
                link_bandwidth = self.loss_model.data_rate_bps(
                    distance_m, len(self.sat_coverage[sat_name])
                )/1000000000

            # When pathloss model is not available
            else:
                link_bandwidth = round(
                    self.GSL_CAPACITY/len(self.sat_coverage[sat_name])
                )

            self.sat_net_graph.add_edge(
                gs_name, sat_name, weight=distance_m, capacity=link_bandwidth
            )</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.create_network_graph"><code class="name flex">
<span>def <span class="ident">create_network_graph</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Create network graph using Networkx
- Nodes:
- Ground stations
- Satellites
- Edges:
- GSLs
- ISLs
- Edge attributes
- weight: distance in meters
- capacity: link_bandwidth in Gbps</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_network_graph(self) -&gt; None:
    &#34;&#34;&#34;Create network graph using Networkx
    - Nodes:
        - Ground stations
        - Satellites
    - Edges:
        - GSLs
        - ISLs
    - Edge attributes
        - weight: distance in meters
        - capacity: link_bandwidth in Gbps
    &#34;&#34;&#34;

    # Satellite network graph
    self.sat_net_graph = nx.Graph()

    # Add satellites from each shell
    self.v.log(&#39;Adding satellites into network graph...&#39;)
    for shell in self.shells:
        self._add_satellites_from_shell(shell)

    # Add ISLs from each shell
    self.v.log(&#39;Adding ISLs into network graph...&#39;)
    for shell_id, shell in enumerate(self.shells):
        self.v.rlog(f&#39;Processing... ({shell_id}/{len(self.shells)})&#39;)
        self._add_ISLs_from_shell(shell)
    self.v.clr()</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.disconnect_ground_station"><code class="name flex">
<span>def <span class="ident">disconnect_ground_station</span></span>(<span>self, *gs_names: tuple[str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Remove ground to satellites links from network graph</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gs_names</code></strong> :&ensp;<code>tuple[str]</code></dt>
<dd>Tuple of ground station names ('G-X','G-Y')</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect_ground_station(self, *gs_names: tuple[str]) -&gt; None:
    &#34;&#34;&#34;Remove ground to satellites links from network graph

    Parameters
    -------
    gs_names: tuple[str]
        Tuple of ground station names (&#39;G-X&#39;,&#39;G-Y&#39;)
    &#34;&#34;&#34;

    for gs_name in gs_names:
        gid = self.ground_stations.decode_name(gs_name)
        for sat_name, _ in self.gsls[gid]:
            self.sat_net_graph.remove_edge(gs_name, sat_name)</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.export_gsls"><code class="name flex">
<span>def <span class="ident">export_gsls</span></span>(<span>self, prefix_path: str = '.') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Write GSLs into a JSON file inside time delta at given path (default current directory)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prefix_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File directory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>File name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_gsls(self, prefix_path: str = &#39;.&#39;) -&gt; str:
    &#34;&#34;&#34;Write GSLs into a JSON file inside time delta at given path (default current directory)

    Parameters
    ----------
    prefix_path: str, optional
        File directory

    Returns
    -------
    str
        File name 
    &#34;&#34;&#34;
    # Create directory with time delta
    dir = self._create_export_dir(prefix_path)
    filename = f&#39;{dir}/{self.name}_gsls.json&#39;

    # Convert GSLs in a to dict
    json_data = {}
    for gid, visibility in enumerate(self.gsls):
        json_data[self.ground_stations.encode_name(gid)] = list(visibility)
    return self._write_json_file(json_data, filename)</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.export_k_path_not_found"><code class="name flex">
<span>def <span class="ident">export_k_path_not_found</span></span>(<span>self, prefix_path: str = '.') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Write flows with less then k path into a TXT file inside time delta at given path (default current directory)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prefix_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File directory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>File name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_k_path_not_found(self, prefix_path: str = &#39;.&#39;) -&gt; str:
    &#34;&#34;&#34;Write flows with less then k path into a TXT file inside time delta at given path (default current directory)

    Parameters
    ----------
    prefix_path: str, optional
        File directory

    Returns
    -------
    str
        File name 
    &#34;&#34;&#34;
    # Create directory with time delta
    dir = self._create_export_dir(prefix_path)
    filename = f&#39;{dir}/{self.name}_k_path_not_found.txt&#39;
    return self._write_text_file(self.k_path_not_found, filename)</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.export_no_path_found"><code class="name flex">
<span>def <span class="ident">export_no_path_found</span></span>(<span>self, prefix_path: str = '.') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Write flows with no path into a TXT file inside time delta at given path (default current directory)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prefix_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File directory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>File name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_no_path_found(self, prefix_path: str = &#39;.&#39;) -&gt; str:
    &#34;&#34;&#34;Write flows with no path into a TXT file inside time delta at given path (default current directory)

    Parameters
    ----------
    prefix_path: str, optional
        File directory

    Returns
    -------
    str
        File name 
    &#34;&#34;&#34;
    # Create directory with time delta
    dir = self._create_export_dir(prefix_path)
    filename = f&#39;{dir}/{self.name}_no_path_found.txt&#39;
    return self._write_text_file(self.no_path_found, filename)</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.export_routes"><code class="name flex">
<span>def <span class="ident">export_routes</span></span>(<span>self, prefix_path: str = '.') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Write routes into a JSON file inside time delta at given path (default current directory)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prefix_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File directory</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>File name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_routes(self, prefix_path: str = &#39;.&#39;) -&gt; str:
    &#34;&#34;&#34;Write routes into a JSON file inside time delta at given path (default current directory)

    Parameters
    ----------
    prefix_path: str, optional
        File directory

    Returns
    -------
    str
        File name 
    &#34;&#34;&#34;
    # Create directory with time delta
    dir = self._create_export_dir(prefix_path)
    filename = f&#39;{dir}/{self.name}_routes.json&#39;

    # Write JSON file
    with open(filename, &#39;w&#39;) as json_file:
        json_file.write(json.dumps(self.routes))

    return filename</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.generate_routes"><code class="name flex">
<span>def <span class="ident">generate_routes</span></span>(<span>self, k: int = 1) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Generate K shortest routes from all terminals to all terminals. </p>
<ul>
<li>Generate routes in dict with key: <code>G-X_G-Y</code></li>
<li>Generate link load dict (number of flow through each link) with key: <code>tuple(hop, hop)</code></li>
<li>Records no path found between two GS: set(flow)</li>
<li>Records if K path not found between two GS: set(flow, # flow found)</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of shortest routes terminal to terminal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def generate_routes(self, k: int = 1) -&gt; None:
    &#34;&#34;&#34;Generate K shortest routes from all terminals to all terminals. \n
    - Generate routes in dict with key: `G-X_G-Y`
    - Generate link load dict (number of flow through each link) with key: `tuple(hop, hop)`
    - Records no path found between two GS: set(flow)
    - Records if K path not found between two GS: set(flow, # flow found)

    Parameters
    --------
    k: int
        Number of shortest routes terminal to terminal
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.gs_info"><code class="name flex">
<span>def <span class="ident">gs_info</span></span>(<span>self, gs_name: str) ‑> tuple[int, <a title="LEOCraft.user_terminals.terminal.TerminalCoordinates" href="../user_terminals/terminal.html#LEOCraft.user_terminals.terminal.TerminalCoordinates">TerminalCoordinates</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get ground station information</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gs_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Ground station name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[int, TerminalCoordinates]</code></dt>
<dd>Ground station ID, TerminalCoordinates dataclass object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gs_info(self, gs_name: str) -&gt; tuple[int, TerminalCoordinates]:
    &#34;&#34;&#34;Get ground station information

    Parameters
    ---------
    gs_name: str
        Ground station name

    Returns
    ---------
    tuple[int, TerminalCoordinates]
        Ground station ID, TerminalCoordinates dataclass object
    &#34;&#34;&#34;

    gid = self.ground_stations.decode_name(gs_name)
    return gid, self.ground_stations.terminals[gid]</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.link_capacity"><code class="name flex">
<span>def <span class="ident">link_capacity</span></span>(<span>self, node_a: str, node_b: str) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the capacity (Gbps) of a link</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_a</code></strong> :&ensp;<code>str</code></dt>
<dd>Satellite/ground station name
in network graph</dd>
<dt><strong><code>node_b</code></strong> :&ensp;<code>str</code></dt>
<dd>Satellite/ground station name in network graph</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Data rate in Gbps</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_capacity(self, node_a: str, node_b: str) -&gt; float:
    &#34;&#34;&#34;Get the capacity (Gbps) of a link

    Parameters
    -------
    node_a: str
        Satellite/ground station name  in network graph
    node_b: str
        Satellite/ground station name in network graph

    Returns
    -------
    float
        Data rate in Gbps
    &#34;&#34;&#34;
    return self.sat_net_graph[node_a][node_b][&#34;capacity&#34;]</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.link_length"><code class="name flex">
<span>def <span class="ident">link_length</span></span>(<span>self, node_a: str, node_b: str) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the length (meters) of a link</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_a</code></strong> :&ensp;<code>str</code></dt>
<dd>Satellite/ground station name
in network graph</dd>
<dt><strong><code>node_b</code></strong> :&ensp;<code>str</code></dt>
<dd>Satellite/ground station name
in network graph</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Length in meters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_length(self, node_a: str, node_b: str) -&gt; float:
    &#34;&#34;&#34;Get the length (meters) of a link

    Parameters
    -------
    node_a: str
        Satellite/ground station name  in network graph
    node_b: str
        Satellite/ground station name  in network graph

    Returns
    -------
    float
        Length in meters
    &#34;&#34;&#34;
    return self.sat_net_graph[node_a][node_b][&#34;weight&#34;]</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.sat_info"><code class="name flex">
<span>def <span class="ident">sat_info</span></span>(<span>self, sat_name: str) ‑> <a title="LEOCraft.satellite_topology.LEO_sat_topology.SatelliteInfo" href="../satellite_topology/LEO_sat_topology.html#LEOCraft.satellite_topology.LEO_sat_topology.SatelliteInfo">SatelliteInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get satellite information at current time delta</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sat_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Satellite name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[int, int, tuple[float, float]]</code></dt>
<dd>Shell ID, Satellite ID, (lat, long)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sat_info(self, sat_name: str) -&gt; SatelliteInfo:
    &#34;&#34;&#34;Get satellite information at current time delta

    Parameters
    ---------
    sat_name: str
        Satellite name

    Returns
    ---------
    tuple[int, int, tuple[float, float]]
        Shell ID, Satellite ID, (lat, long)
    &#34;&#34;&#34;

    shell_id, sid = LEOSatelliteTopology.decode_sat_name(sat_name)
    return self.shells[shell_id].build_sat_info(sid, self.time_delta)</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.set_loss_model"><code class="name flex">
<span>def <span class="ident">set_loss_model</span></span>(<span>self, model: <a title="LEOCraft.attenuation.fspl.FSPL" href="../attenuation/fspl.html#LEOCraft.attenuation.fspl.FSPL">FSPL</a> | None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set path-loss model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_loss_model(self, model: FSPL | None) -&gt; None:
    &#34;Set path-loss model&#34;
    self.loss_model = model</code></pre>
</details>
</dd>
<dt id="LEOCraft.constellations.constellation.Constellation.set_time"><code class="name flex">
<span>def <span class="ident">set_time</span></span>(<span>self, day: int = 0, hour: int = 0, minute: int = 0, second: int = 0, millisecond: int = 0, nanosecond: int = 0) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the simulation time, i.e., time passed from the epoch. Default values are zero (0)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>day</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>hour</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>minute</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>second</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>millisecond</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>nanosecond</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time(
    self,
    day: int = 0,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    millisecond: int = 0,
    nanosecond: int = 0
) -&gt; None:
    &#34;&#34;&#34;Sets the simulation time, i.e., time passed from the epoch. Default values are zero (0)

    Parameters
    ----------
    day : int, optional
    hour: int, optional
    minute: int, optional
    second: int, optional
    millisecond: int, optional
    nanosecond: int, optional
    &#34;&#34;&#34;
    self.time_delta = self.calculate_time_delta(
        day, hour, minute, second, millisecond, nanosecond
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="LEOCraft.constellations" href="index.html">LEOCraft.constellations</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="LEOCraft.constellations.constellation.Constellation" href="#LEOCraft.constellations.constellation.Constellation">Constellation</a></code></h4>
<ul class="">
<li><code><a title="LEOCraft.constellations.constellation.Constellation.GSL_CAPACITY" href="#LEOCraft.constellations.constellation.Constellation.GSL_CAPACITY">GSL_CAPACITY</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.ISL_CAPACITY" href="#LEOCraft.constellations.constellation.Constellation.ISL_CAPACITY">ISL_CAPACITY</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.add_ground_stations" href="#LEOCraft.constellations.constellation.Constellation.add_ground_stations">add_ground_stations</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.add_shells" href="#LEOCraft.constellations.constellation.Constellation.add_shells">add_shells</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.build" href="#LEOCraft.constellations.constellation.Constellation.build">build</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.calculate_time_delta" href="#LEOCraft.constellations.constellation.Constellation.calculate_time_delta">calculate_time_delta</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.connect_ground_station" href="#LEOCraft.constellations.constellation.Constellation.connect_ground_station">connect_ground_station</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.create_network_graph" href="#LEOCraft.constellations.constellation.Constellation.create_network_graph">create_network_graph</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.disconnect_ground_station" href="#LEOCraft.constellations.constellation.Constellation.disconnect_ground_station">disconnect_ground_station</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.export_gsls" href="#LEOCraft.constellations.constellation.Constellation.export_gsls">export_gsls</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.export_k_path_not_found" href="#LEOCraft.constellations.constellation.Constellation.export_k_path_not_found">export_k_path_not_found</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.export_no_path_found" href="#LEOCraft.constellations.constellation.Constellation.export_no_path_found">export_no_path_found</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.export_routes" href="#LEOCraft.constellations.constellation.Constellation.export_routes">export_routes</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.generate_routes" href="#LEOCraft.constellations.constellation.Constellation.generate_routes">generate_routes</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.gs_info" href="#LEOCraft.constellations.constellation.Constellation.gs_info">gs_info</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.k" href="#LEOCraft.constellations.constellation.Constellation.k">k</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.link_capacity" href="#LEOCraft.constellations.constellation.Constellation.link_capacity">link_capacity</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.link_length" href="#LEOCraft.constellations.constellation.Constellation.link_length">link_length</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.sat_info" href="#LEOCraft.constellations.constellation.Constellation.sat_info">sat_info</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.set_loss_model" href="#LEOCraft.constellations.constellation.Constellation.set_loss_model">set_loss_model</a></code></li>
<li><code><a title="LEOCraft.constellations.constellation.Constellation.set_time" href="#LEOCraft.constellations.constellation.Constellation.set_time">set_time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>